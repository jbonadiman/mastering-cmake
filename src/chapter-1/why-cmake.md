# Why CMake?
If you have ever maintained the build and installation process for a software package, you will be interested in CMake. CMake is an open-source build system generator for software projects that allows developers to specify build parameters in a simple, portable, text file format. This file is then used by CMake to generate project files for native build tools including Integrated Development Environments (IDEs) such as Microsoft Visual Studio or Apple’s Xcode, as well as UNIX, Linux, NMake, and Ninja. CMake handles the difficult aspects of building software such as cross-platform builds, system introspection, and user customized builds, in a simple manner that allows users to easily tailor builds for complex hardware and software systems.

For any project, and especially cross-platform projects, there is a need for a unified build system. Many non CMake-based projects ship with both a UNIX Makefile (or Makefile.in) and a Microsoft Visual Studio workspace. This requires that developers constantly try to keep both build systems up-to-date and consistent with each other. To target additional build systems, such as Xcode, requires even more custom copies of these files, creating an even bigger problem. This problem is compounded if you try to support optional components, such as including JPEG support if libjpeg is available on the system. CMake solves this by consolidating these different operations into one simple, easy-to-understand file format.

If you have multiple developers working on a project, or multiple target platforms, then the software will have to be built on more than one computer. Given the wide range of installed software and custom options that are involved with setting up a modern computer, the chances are that two computers running the same OS will be slightly different. CMake provides many benefits for single platform, multi-machine development environments including:
- The ability to automatically search for programs, libraries, and header files that may be required by the software being built. This includes the ability to consider environment variables and Window’s registry settings when searching.
- The ability to build in a directory tree outside of the source tree. This is a useful feature found on many UNIX platforms; CMake provides this feature on Windows as well. This allows a developer to remove an entire build directory without fear of removing source files.
- The ability to create complex, custom commands for automatically generated files such as [Qt](http://qt.io/)’s moc() or [SWIG](http://www.swig.org/) wrapper generators. These commands are used to generate new source files during the build process that are in turn compiled into the software.
- The ability to select optional components at configuration time. For example, several of [VTK](http://www.vtk.org/)’s libraries are optional, and CMake provides an easy way for users to select which libraries are built.
- The ability to automatically generate workspaces and projects from a simple text file. This can be very handy for systems that have many programs or test cases, each of which requires a separate project file, typically a tedious manual process to create using an IDE.
- The ability to easily switch between static and shared builds. CMake knows how to create shared libraries and modules on all platforms supported. Complicated platform-specific linker flags are handled, and advanced features like built-in run time search paths for shared libraries are supported on many UNIX systems.
- Automatic generation of file dependencies and support for parallel builds on most platforms.

When developing cross-platform software, CMake provides a number of additional features:
- The ability to test for machine byte order and other hardware-specific characteristics.
- A single set of build configuration files that work on all platforms. This avoids the problem of developers having to maintain the same information in several different formats inside a project.
- Support for building shared libraries on all platforms that support it.
- The ability to configure files with system-dependent information, such as the location of data files and other information. CMake can create header files that contain information such as paths to data files and other information in the form of `#define` macros. System specific flags can also be placed in configured header files. This has advantages over command line -D options to the compiler, because it allows other build systems to use the CMake built library without having to specify the exact same command line options used during the build.
