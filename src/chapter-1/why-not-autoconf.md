# Why Not Use Autoconf?
Before developing CMake, its authors had experience with the existing set of available build tools. Autoconf combined with Automake provides some of the same functionality as CMake, but to use these tools on a Windows platform requires the installation of many additional tools not found natively on a Windows box. In addition to requiring a host of tools, autoconf can be difficult to use or extend, and impossible for performing some tasks that are easy in CMake. Even if you do get autoconf and its required environment running on your system, it generates Makefiles that will force users to the command line. CMake on the other hand, provides a choice, allowing developers to generate project files that can be used directly from the IDE to which Windows and Xcode developers are accustomed.

While autoconf supports user-specified options, it does not support dependent options where one option depends on another property or selection. For example, in CMake you could have a user option to have multithreading be dependent on first determining if the user’s system has multithreading support. CMake provides an interactive user interface, making it easy for the user to see which options are available and how to set them.

For UNIX users, CMake also provides automated dependency generation that is not done directly by autoconf. CMake’s simple input format is also easier to read and maintain than a combination of Makefile.in and configure.in files. The ability of CMake to remember and chain library dependency information has no equivalent in autoconf/automake.

